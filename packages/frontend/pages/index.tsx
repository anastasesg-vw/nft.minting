import moment from 'moment';
import type { NextPage } from 'next';
import Head from 'next/head';
import Image from 'next/image';
import { useEffect, useState } from 'react';
import { toast } from 'react-toastify';
import signatures from '../config/signatures.example.json';
import { useWeb3Context } from '../src/context';
import axios from 'axios';

interface Token {
  dna: string;
  name: string;
  description: string;
  image: string;
  edition: number;
  date: Date;
  attributes: {
    trait_type: string;
    value: string;
  }[];
  compiler: string;
}

const Home: NextPage = () => {
  const { web3Provider, address, nft, connect, disconnect } = useWeb3Context();
  // const [count, setCount] = useState<number>(1);
  const [preSaleDateTime, setPreSaleDateTime] = useState<Date | null>();
  const [publicSaleDateTime, setPublicSaleDateTime] = useState<Date | null>();
  const [tokens, setTokens] = useState<Token[]>([]);

  useEffect(() => {
    if (nft) {
      const getPreSaleTime = async () => {
        return await nft.prSaleTime();
      };

      const getPublicSaleTime = async () => {
        return await nft.puSaleTime();
      };

      getPublicSaleTime().then((time) => {
        setPublicSaleDateTime(new Date(time.toNumber() * 1000));
      });

      getPreSaleTime().then((time) => {
        setPreSaleDateTime(new Date(time.toNumber() * 1000));
      });
    }
  }, [nft]);

  useEffect(() => {
    if (web3Provider && nft && address) {
      const getTokens = async () => {
        const tkns: Token[] = [];
        for (let index = 0; index < 80; index++) {
          if (await nft.ownerOf(index + 1)) {
            const tokenUri = await nft.tokenURI(index + 1);
            const url = `https://ipfs.io/ipfs/${tokenUri.replace(
              'ipfs://',
              '',
            )}`;
            tkns[index] = (await axios.get<Token>(url)).data;
            tkns[index].image = `https://ipfs.io/ipfs/${tkns[
              index
            ].image.replace('ipfs://', '')}`;
          }
        }

        console.log(tkns);
        return tkns;
      };

      getTokens().then((response) => {
        setTokens(response);
      });
    }
  }, [web3Provider, nft, address]);

  const onMintClick = async () => {
    if (web3Provider && nft && address) {
      let signature: string = signatures.hasOwnProperty(address)
        ? signatures[address.toLowerCase()]
        : signatures['default'];

      const mint = async (amount: number) =>
        moment.utc().isAfter(preSaleDateTime) &&
        moment.utc().isBefore(publicSaleDateTime) &&
        address
          ? nft.preSaleMint(amount, signature, {
              value: (
                (await nft.preSalePrice()).toNumber() * amount
              ).toString(),
            })
          : nft.pubSaleMint(amount, {
              value: (
                (await nft.pubSalePrice()).toNumber() * amount
              ).toString(),
            });

      mint(100).catch((e: any) => {
        let error: string = '';

        if (e.message) {
          error = e.message;
        }

        if (error.includes('AntiBot')) {
          toast.error(
            'We have detected that you are or using a bot. If you are not please contact the contract owner.',
          );
        } else if (error.includes('PubSaleNotStarted')) {
          toast.error('The public sale has not started yet!');
        } else if (error.includes('PreSaleNotStarted')) {
          toast.error('The sale has not started yet!');
        } else if (error.includes('PreSaleEnded')) {
          toast.error('The pre sale has ended!');
        } else if (error.includes('PubSaleEnded')) {
          toast.error('The public sale has ended!');
        } else if (error.includes('ExceedMaxAmount')) {
          toast.error(
            'You have exceeded the max number of tokens you can mint!',
          );
        } else if (error.includes('ExceedMaxSupply')) {
          toast.error('There are no tokens left to mint!');
        } else if (error.includes('ValueTooLow')) {
          toast.error('You have not given the correct amount of ETH!');
        } else if (error.includes('NotWhitelisted')) {
          toast.error(
            'You are not whitelisted! Wait for the public sale to start!',
          );
        } else {
          toast.error(e);
        }
      });
    }
  };

  return (
    <div className="flex h-screen">
      <div className="m-auto">
        <Head>
          <title>Generic NFT Minting dApp</title>
          <meta name="description" content="Generated by create next app" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
        <header className="pt-8 pb-4 text-center text-4xl font-semibold">
          Generic NFT Minting dApp
        </header>
        <main className="container mx-auto flex flex-col items-center">
          {web3Provider ? (
            <button type="button" onClick={disconnect!}>
              Disconnect
            </button>
          ) : (
            <button type="button" onClick={connect!}>
              Connect
            </button>
          )}
          <button type="button" onClick={onMintClick}>
            Mint
          </button>
          <div className="grid grid-cols-4">
            {tokens.map((token) => {
              return (
                <div className="p-4">
                  <img
                    src={token.image}
                    width={100}
                    height={100}
                    key={token.name}
                  />
                </div>
              );
            })}
          </div>
        </main>
        <footer></footer>
      </div>
    </div>
  );
};

export default Home;
